"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const moment = require("moment");
const request = require("superagent");
class Client {
    constructor(options) {
        this.pollingInterval = options.pollingInterval || 1000;
        this.waitTimeout = options.waitTimeout || 60000;
        this.endpoint = options.endpoint || "https://mailtrap.io/api/v1";
        this.apiToken = options.apiToken;
    }
    getInbox(inboxID) {
        return this.getJSON(`/inboxes/${inboxID}`);
    }
    getInboxes(inboxFilter) {
        return this.getJSON("/inboxes")
            .then((inboxes) => {
            if (inboxFilter) {
                return inboxes.filter(inboxFilter);
            }
            return inboxes;
        });
    }
    getMessages(inboxID, messageFilter) {
        return this.getJSON(`/inboxes/${inboxID}/messages`)
            .then((messages) => {
            if (messageFilter) {
                return messages.filter(messageFilter);
            }
            return messages;
        });
    }
    deleteMessage(inboxID, messageID) {
        return this.delete(`/inboxes/${inboxID}/messages/${messageID}`);
    }
    deleteMessages(inboxID, messageFilter) {
        return this.getMessages(inboxID, messageFilter)
            .then((messages) => Promise.all(messages.map((message) => this.deleteMessage(inboxID, message.id))));
    }
    getMessageBody(inboxID, messageID, bodyType) {
        return this.getText(`/inboxes/${inboxID}/messages/${messageID}/body.${bodyType.toString()}`);
    }
    waitForMessages(inboxID, condition, messageFilter, startTime) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!startTime) {
                startTime = moment();
            }
            const messages = yield this.getMessages(inboxID, messageFilter);
            const conditionResult = yield condition(messages);
            if (conditionResult) {
                return;
            }
            yield new Promise((resolve) => setTimeout(resolve, this.pollingInterval));
            if (this.isWaitTimeoutExceeded(startTime)) {
                throw new Error("Timed out waiting for messages");
            }
            return this.waitForMessages(inboxID, condition, messageFilter, startTime);
        });
    }
    delete(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield request.delete(`${this.endpoint}${path}`).set("Authorization", `Token token=${this.apiToken}`);
            return res.text;
        });
    }
    get(path) {
        return request(`${this.endpoint}${path}`).set("Authorization", `Token token=${this.apiToken}`);
    }
    getJSON(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(path);
            return res.body;
        });
    }
    getText(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(path);
            return res.text;
        });
    }
    isWaitTimeoutExceeded(startTime) {
        const duration = moment.duration(moment().diff(startTime));
        if (this.waitTimeout - duration.asMilliseconds() > 0) {
            return false;
        }
        return true;
    }
}
exports.Client = Client;
